program = code

code = statement*

statement = "let" variable_declaration
          / assignment
          / expr

variable_declaration  = decl ("," decl)*

decl = identifier ("=" expr)?

identifier = pattern:([a-z][a-zA-Z_0-9]*) { return text(pattern); }

variable_reference = identifier

if_expression = expr brace_block ( "else" brace_block )?

assignment  = identifier "=" expr

expr  = "fn" function_definition
      / "if" if_expression
      / arithmetic_expression
      / boolean_expression

boolean_expression  = arithmetic_expression relop arithmetic_expression

arithmetic_expression  = pattern:(mult_term addop arithmetic_expression) { return {type: "arithmetic_expr", params: pattern} }
                       / mult_term

mult_term  = pattern:(primary mulop mult_term) { return {type: "arithmetic_expr", params: pattern}; }
           / primary

primary  = _ value:integer _ { return {type: "integer", value: value} }
         / function_call
         / variable_reference
         / "(" arithmetic_expression ")"

integer = sign:"-"? num:[0-9]+ { return sign ? Number((sign+num).replace(',','')) : Number(num.toString().replace(',',''));}

addop   =   '+' 
          / '-' 
mulop   =   '*' 
          / '/' 
relop   =   '=='
          / '!='
          / '>='
          / '>' 
          / '<='
          / '<' 

function_call  = fcn_name:"print" "(" params:call_arguments ")" { return {type: "function", fcn_name, params}; }
                  / fcn_name:variable_reference "(" params:call_arguments ")" { return {type: "function", fcn_name, params}; }

call_arguments = pattern:(expr ("," expr)*)? { return pattern && pattern[0].length ? pattern[0] : pattern; }

function_definition = param_list brace_block

param_list =  "(" identifier ("," identifier)* ")"
           /  "()"

brace_block = "{" code "}"

whitespace = [ \t\r\n]+
comment_chars = [. \t]*
comment = "#" comment_chars [\r\n]

_ = ( whitespace / comment )*