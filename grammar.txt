program = code

code = statement*

statement = _ "let" _ variable_dec:variable_declaration _ { return variable_dec; }
          / assignment
          / expr:expr _ { return expr; }

variable_declaration  = dec:(decl repeat_declaration) { const declarations = dec[1].length ? [dec[0], ...dec[1]] : [dec[0]]; return {type: "variable_dec", declarations }; }

repeat_declaration = dec:(("," _ decl)*) { const finalDec = dec.length ? dec.map(d => {return d[2]}) : []; return finalDec; }

decl = name:identifier _ "=" expr:expr { return {type: "assignment", name, expr}; }
      / name:identifier { return {type: "assignment", name}; }

identifier = pattern:([a-z][a-zA-Z0-9]*) { return text(pattern); }

variable_reference = name:identifier { return {type: "identifier", name}; }

if_expression = _ evaluation:expr _ statements:brace_block _ else_statements:else_expression? { return { evaluation, statements, else_statements }; }

else_expression = "else" _ statements:brace_block { return statements; }

assignment  = _ name:identifier _ "=" expr:expr { return {type: "assignment", name, expr}; }

expr  = _ "fn" _ def:function_definition { return def; }
      / _ "if" _ expr:if_expression { return {type: "if", evaluation: expr.evaluation, statements: expr.statements, else_statements: expr.else_statements}; }
      / boolean_expression
      / arithmetic_expression
      
boolean_expression  = params:(arithmetic_expression relop arithmetic_expression) { return {type: "boolean_expr", params}; }

arithmetic_expression  = pattern:(mult_term addop arithmetic_expression) { return {type: "arithmetic_expr", params: pattern} }
                       / mult_term

mult_term  = pattern:(primary mulop mult_term) { return {type: "arithmetic_expr", params: pattern}; }
           / primary

primary  = _ value:integer _ { return {type: "integer", value: value} }
         / _ fcn:function_call { return fcn; }
         / _ ref:variable_reference { return ref; }
         / "(" arithmetic_expression ")"

integer = sign:"-"? num:[0-9]+ { return sign ? Number((sign+num).replace(/,/g, '')) : Number(num.toString().replace(/,/g, ''));}

addop   =   _ op:'+' {return op;}
          / _ op:'-' {return op;}
mulop   =   '*' 
          / '/' 
relop   =   '=='
          / '!='
          / '>='
          / '>' 
          / '<='
          / '<' 

function_call  = fcn_name:"print" "(" params:call_arguments ")" { return {type: "function_call", fcn_name, params}; }
                  / fcn_name:variable_reference "(" params:call_arguments ")" { return {type: "function_call", fcn_name, params}; }

call_arguments = arg:((expr repeat_arg)?) { if (!arg) { return []; } const args = arg[1].length ? [arg[0], ...arg[1]] : [arg[0]]; return args; }

repeat_arg = arg:(("," expr)*) { const finalArg = arg.length ? arg.map(a => a[1]) : []; return finalArg; }

function_definition = params:param_list _ body:brace_block { return {type: "function_def", params, body}; }

param_list = "(" pattern:(identifier ("," identifier)*) ")" { return pattern; }
           / "()" { return []; }

brace_block = "{" _ code:code _ "}" { return code; }

whitespace = [ \t\r\n]+
line_terminator = [\r\n]
comment = "#" (!line_terminator .)* line_terminator

_ = ( whitespace / comment )*